#map0 = affine_map<(d0, d1) -> (d0 * 64 + d1)>
#map1 = affine_map<(d0) -> (d0 * -2 + 3, 0)>
#map2 = affine_map<(d0) -> (d0 * -2 + 227, 7)>
#map3 = affine_map<(d0, d1) -> (d1 * -2 + 3, 0)>
#map4 = affine_map<(d0, d1) -> (d1 * -2 + 227, 7)>
#map5 = affine_map<(d0, d1) -> (d0 + d1 * 3)>
#map6 = affine_map<(d0, d1) -> (d0 + d1 * 2 - 3)>
#map7 = affine_map<(d0) -> (0, d0 * 2 - 1)>
#map8 = affine_map<(d0)[s0, s1, s2, s3, s4] -> (s0 - ((s2 ceildiv s4) * s4 - s2), -(d0 * s3 - s2) + s0, d0 * s3 + (s1 - 1) * s4 - s2 - ((s2 ceildiv s4) * s4 - s2) + 1, d0 * s3 + (s1 - 1) * s4 - s2 - (d0 * s3 - s2) + 1)>
#map9 = affine_map<(d0) -> (-d0 + 1, 0)>
#map10 = affine_map<(d0) -> (-d0 + 57, 3)>
#map11 = affine_map<(d0, d1) -> (-d1 + 1, 0)>
#map12 = affine_map<(d0, d1) -> (-d1 + 57, 3)>
#map13 = affine_map<(d0, d1) -> (d0 + d1 * 64)>
#map14 = affine_map<(d0, d1) -> (d0 + d1 - 1)>
#map15 = affine_map<(d0, d1) -> (d0 * 128 + d1)>
#map16 = affine_map<(d0) -> (d0 * -2 + 1, 0)>
#map17 = affine_map<(d0) -> (d0 * -2 + 57, 3)>
#map18 = affine_map<(d0, d1) -> (d1 * -2 + 1, 0)>
#map19 = affine_map<(d0, d1) -> (d1 * -2 + 57, 3)>
#map20 = affine_map<(d0, d1) -> (d0 + d1 * 2 - 1)>
#map21 = affine_map<(d0) -> (-d0 + 29, 3)>
#map22 = affine_map<(d0, d1) -> (-d1 + 29, 3)>
#map23 = affine_map<(d0, d1) -> (d0 + d1 * 128)>
#map24 = affine_map<(d0) -> (d0 * -2, 0)>
#map25 = affine_map<(d0) -> (d0 * -2 + 56, 1)>
#map26 = affine_map<(d0, d1) -> (d1 * -2, 0)>
#map27 = affine_map<(d0, d1) -> (d1 * -2 + 56, 1)>
#map28 = affine_map<(d0, d1) -> (d0 + d1 * 2)>
#map29 = affine_map<(d0, d1) -> (d0 * 256 + d1)>
#map30 = affine_map<(d0) -> (d0 * -2 + 29, 3)>
#map31 = affine_map<(d0, d1) -> (d1 * -2 + 29, 3)>
#map32 = affine_map<(d0) -> (-d0 + 15, 3)>
#map33 = affine_map<(d0, d1) -> (-d1 + 15, 3)>
#map34 = affine_map<(d0, d1) -> (d0 + d1 * 256)>
#map35 = affine_map<(d0) -> (d0 * -2 + 28, 1)>
#map36 = affine_map<(d0, d1) -> (d1 * -2 + 28, 1)>
#map37 = affine_map<(d0, d1) -> (d0 * 512 + d1)>
#map38 = affine_map<(d0) -> (d0 * -2 + 15, 3)>
#map39 = affine_map<(d0, d1) -> (d1 * -2 + 15, 3)>
#map40 = affine_map<(d0) -> (-d0 + 8, 3)>
#map41 = affine_map<(d0, d1) -> (-d1 + 8, 3)>
#map42 = affine_map<(d0, d1) -> (d0 + d1 * 512)>
#map43 = affine_map<(d0) -> (d0 * -2 + 14, 1)>
#map44 = affine_map<(d0, d1) -> (d1 * -2 + 14, 1)>
#map45 = affine_map<(d0, d1, d2) -> (d0 + d1 + d2)>
module attributes {llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu"} {
  func @main_graph(%arg0: memref<1x3x224x224xf32>) -> memref<1x1000xf32> attributes {input_names = ["input"], output_names = ["191"]} {
    %cst = arith.constant 0xFF800000 : f32
    %c112 = arith.constant 112 : index
    %c3 = arith.constant 3 : index
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %c0 = arith.constant 0 : index
    %cst_0 = arith.constant 4.900000e+01 : f32
    %cst_1 = arith.constant 0.000000e+00 : f32
    %0 = "krnl.global"() {name = "constant_0", shape = [64, 3, 7, 7], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<64x3x7x7xf32>} : () -> memref<64x3x7x7xf32>
    %1 = "krnl.global"() {name = "constant_1", shape = [64], value = dense<[0.230072439, 0.25738138, -1.05429467E-6, -0.640167057, -1.65705778E-8, 0.16138573, 4.590370e-01, -4.30190198E-7, 0.301778793, -8.00537146E-6, 3.432430e-01, 0.306642622, -0.241098836, -3.474420e-05, 0.10718032, 0.217505932, 0.370913982, -0.549993813, -6.389300e-01, 0.578532577, 0.305243224, 0.574288666, 0.48838082, 0.332184464, 0.19620654, 0.191609904, 0.153543428, 0.0980728268, 0.496284395, 0.0250270106, 0.164623857, 0.326752871, 0.258347631, 0.444027483, -0.302922338, -0.0200951453, -2.45067355E-7, 3.168060e-01, -4.91517085E-8, 0.23523429, 0.234517872, 0.311931521, 0.433292478, 0.288427532, 0.258658648, 0.693289161, 0.421915919, 0.340013146, -8.69091678E-8, 0.250960439, 3.044630e-01, 0.623376369, 0.389313072, 0.327964604, -0.40447852, 0.382038862, 0.181512922, 0.252001077, -0.428291529, 0.213704288, 0.576516449, 0.563062727, -0.391487837, 0.236812189]> : tensor<64xf32>} : () -> memref<64xf32>
    %2 = memref.alloc() {alignment = 16 : i64} : memref<1x64x112x112xf32>
    %3 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 64 {
          %113 = affine.apply #map0(%arg2, %arg3)
          affine.for %arg4 = 0 to 112 {
            affine.for %arg5 = 0 to 112 {
              affine.store %cst_1, %3[] : memref<f32>
              affine.for %arg6 = 0 to 3 {
                affine.for %arg7 = max #map1(%arg4) to min #map2(%arg4) {
                  affine.for %arg8 = max #map3(%arg4, %arg5) to min #map4(%arg4, %arg5) {
                    %117 = affine.apply #map5(%arg6, %arg2)
                    %118 = affine.apply #map6(%arg7, %arg4)
                    %119 = affine.apply #map6(%arg8, %arg5)
                    %120 = affine.load %arg0[%arg1, %117, %118, %119] : memref<1x3x224x224xf32>
                    %121 = affine.load %0[%113, %arg6, %arg7, %arg8] : memref<64x3x7x7xf32>
                    %122 = affine.load %3[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %3[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %3[] : memref<f32>
              %115 = affine.load %1[%113] : memref<64xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %2[%arg1, %113, %arg4, %arg5] : memref<1x64x112x112xf32>
            }
          }
        }
      }
    }
    %4 = memref.alloc() {alignment = 16 : i64} : memref<1x64x112x112xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 64 {
        affine.for %arg3 = 0 to 112 {
          affine.for %arg4 = 0 to 112 {
            %113 = affine.load %2[%arg1, %arg2, %arg3, %arg4] : memref<1x64x112x112xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %4[%arg1, %arg2, %arg3, %arg4] : memref<1x64x112x112xf32>
          }
        }
      }
    }
    %5 = memref.alloc() {alignment = 16 : i64} : memref<1x64x56x56xf32>
    %6 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 64 {
        affine.for %arg3 = 0 to 56 {
          affine.for %arg4 = 0 to 56 {
            affine.store %cst, %6[] : memref<f32>
            %113 = affine.max #map7(%arg3)
            %114 = affine.max #map7(%arg4)
            affine.for %arg5 = 0 to min #map8(%arg3)[%c112, %c3, %c1, %c2, %c1] {
              affine.for %arg6 = 0 to min #map8(%arg4)[%c112, %c3, %c1, %c2, %c1] {
                %116 = arith.addi %arg5, %113 : index
                %117 = arith.addi %arg6, %114 : index
                %118 = memref.load %4[%arg1, %arg2, %116, %117] : memref<1x64x112x112xf32>
                %119 = affine.load %6[] : memref<f32>
                %120 = arith.cmpf ogt, %119, %118 : f32
                %121 = arith.select %120, %119, %118 : f32
                affine.store %121, %6[] : memref<f32>
              }
            }
            %115 = affine.load %6[] : memref<f32>
            affine.store %115, %5[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
          }
        }
      }
    }
    %7 = "krnl.global"() {name = "constant_2", shape = [64, 64, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<64x64x3x3xf32>} : () -> memref<64x64x3x3xf32>
    %8 = "krnl.global"() {name = "constant_3", shape = [64], value = dense<[0.368625581, 0.325406641, 0.162939504, 0.3600761, 0.651467323, 0.454972982, 0.343590021, 1.455040e-01, 0.544603944, 0.317904472, 0.10874702, 0.821084856, 0.175163954, 0.355256975, 0.353129387, 0.374298066, 0.656303107, 0.0259432048, 0.819895744, 0.304631174, 0.478492856, 0.677211284, 0.79397893, 0.405464709, 0.112229377, 0.13529554, -0.100194827, 0.701283633, -6.1775744E-4, -0.243418038, -0.0761035681, 0.887794375, 0.540957928, 1.08511865, 0.874500513, 0.547298789, 0.498215318, 0.126264408, 1.07440555, 0.852854251, 0.195609748, 0.595376432, -0.172516406, -0.566736639, 0.341160148, 0.515221179, 1.10221064, 0.865594446, 0.859734177, 0.999848723, 6.776850e-01, 1.02323425, 0.385160267, 0.768912315, 0.981966972, -0.634059906, 0.615600348, 0.17940405, 0.547713757, 0.104524434, 0.363692045, 0.739562154, -0.819639086, 0.512547255]> : tensor<64xf32>} : () -> memref<64xf32>
    %9 = memref.alloc() {alignment = 16 : i64} : memref<1x64x56x56xf32>
    %10 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 64 {
          %113 = affine.apply #map0(%arg2, %arg3)
          affine.for %arg4 = 0 to 56 {
            affine.for %arg5 = 0 to 56 {
              affine.store %cst_1, %10[] : memref<f32>
              affine.for %arg6 = 0 to 64 {
                affine.for %arg7 = max #map9(%arg4) to min #map10(%arg4) {
                  affine.for %arg8 = max #map11(%arg4, %arg5) to min #map12(%arg4, %arg5) {
                    %117 = affine.apply #map13(%arg6, %arg2)
                    %118 = affine.apply #map14(%arg7, %arg4)
                    %119 = affine.apply #map14(%arg8, %arg5)
                    %120 = affine.load %5[%arg1, %117, %118, %119] : memref<1x64x56x56xf32>
                    %121 = affine.load %7[%113, %arg6, %arg7, %arg8] : memref<64x64x3x3xf32>
                    %122 = affine.load %10[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %10[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %10[] : memref<f32>
              %115 = affine.load %8[%113] : memref<64xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %9[%arg1, %113, %arg4, %arg5] : memref<1x64x56x56xf32>
            }
          }
        }
      }
    }
    %11 = memref.alloc() {alignment = 16 : i64} : memref<1x64x56x56xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 64 {
        affine.for %arg3 = 0 to 56 {
          affine.for %arg4 = 0 to 56 {
            %113 = affine.load %9[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %11[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
          }
        }
      }
    }
    %12 = "krnl.global"() {name = "constant_4", shape = [64, 64, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<64x64x3x3xf32>} : () -> memref<64x64x3x3xf32>
    %13 = "krnl.global"() {name = "constant_5", shape = [64], value = dense<[0.103008054, 0.00309037184, -1.25119925, -0.351913691, 0.082185626, -0.14083688, 2.665080e-02, 0.0204582382, 0.949822068, -0.0621062703, 0.0724402443, 0.481205106, 0.0828189775, -0.162278801, 0.00130670518, 0.137527525, -0.0446104854, -0.175678492, -0.259507954, -0.396142602, -0.549273729, 0.12522909, -0.321095139, 0.135347754, -0.0377938636, 0.592934072, -0.0349574685, -0.106193721, 0.286738783, 0.22980997, 4.801530e-01, 0.271719605, -0.00485835969, 0.334993124, 0.10948839, -0.0534392074, -0.831641972, 0.511684537, 0.397977889, 0.490740716, 0.377787948, 0.128160924, 0.0298982039, 0.0937353373, -0.19215025, -0.0358871222, 1.78533447, -0.0524050817, 0.0106833568, 0.210487589, 0.727525592, -0.118608385, 0.0733637511, 0.225289643, -0.40583241, 0.243932605, 0.16569525, -0.11167834, 0.355954885, -0.278496772, -0.0530226491, 0.188364819, -0.270659924, 0.28098911]> : tensor<64xf32>} : () -> memref<64xf32>
    %14 = memref.alloc() {alignment = 16 : i64} : memref<1x64x56x56xf32>
    %15 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 64 {
          %113 = affine.apply #map0(%arg2, %arg3)
          affine.for %arg4 = 0 to 56 {
            affine.for %arg5 = 0 to 56 {
              affine.store %cst_1, %15[] : memref<f32>
              affine.for %arg6 = 0 to 64 {
                affine.for %arg7 = max #map9(%arg4) to min #map10(%arg4) {
                  affine.for %arg8 = max #map11(%arg4, %arg5) to min #map12(%arg4, %arg5) {
                    %117 = affine.apply #map13(%arg6, %arg2)
                    %118 = affine.apply #map14(%arg7, %arg4)
                    %119 = affine.apply #map14(%arg8, %arg5)
                    %120 = affine.load %11[%arg1, %117, %118, %119] : memref<1x64x56x56xf32>
                    %121 = affine.load %12[%113, %arg6, %arg7, %arg8] : memref<64x64x3x3xf32>
                    %122 = affine.load %15[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %15[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %15[] : memref<f32>
              %115 = affine.load %13[%113] : memref<64xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %14[%arg1, %113, %arg4, %arg5] : memref<1x64x56x56xf32>
            }
          }
        }
      }
    }
    %16 = memref.alloc() {alignment = 16 : i64} : memref<1x64x56x56xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 64 {
        affine.for %arg3 = 0 to 56 {
          affine.for %arg4 = 0 to 56 {
            %113 = affine.load %14[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
            %114 = affine.load %5[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
            %115 = arith.addf %113, %114 : f32
            affine.store %115, %16[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
          }
        }
      }
    }
    %17 = memref.alloc() {alignment = 16 : i64} : memref<1x64x56x56xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 64 {
        affine.for %arg3 = 0 to 56 {
          affine.for %arg4 = 0 to 56 {
            %113 = affine.load %16[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %17[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
          }
        }
      }
    }
    %18 = "krnl.global"() {name = "constant_6", shape = [64, 64, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<64x64x3x3xf32>} : () -> memref<64x64x3x3xf32>
    %19 = "krnl.global"() {name = "constant_7", shape = [64], value = dense<[0.203268796, -1.0184617, 0.593197227, 0.141449451, 0.288950562, 0.827276885, 0.196085468, 0.0196650699, 0.244019315, 0.339629918, 3.982730e-01, 0.225417063, 0.826109528, 0.324727446, -0.11941433, -0.116409257, 0.236152679, 0.0745340139, 0.681738436, 0.187584847, -0.242616683, 0.785294771, 0.706127763, -0.0477594212, -0.201818526, 0.699112892, 0.830296278, 0.455139488, -4.449560e-01, 0.0362849943, -0.433717549, 1.08769763, 0.454196274, -0.0122724622, 0.827152132, 1.2079196, -0.0205453485, -0.0956097692, 0.326867789, 0.648125648, -0.810206532, 0.124251075, -0.443018705, 0.483014554, 5.707790e-01, 0.104257353, -0.13691394, -0.10740488, -1.01504886, 0.337919861, -0.0316243246, 0.684680879, 0.146421611, 0.351496249, 0.800712764, 0.0669396594, 0.416208833, 0.354297578, 0.0449918881, 0.874896288, 0.555173159, -0.0346075408, -0.727050244, 0.555207849]> : tensor<64xf32>} : () -> memref<64xf32>
    %20 = memref.alloc() {alignment = 16 : i64} : memref<1x64x56x56xf32>
    %21 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 64 {
          %113 = affine.apply #map0(%arg2, %arg3)
          affine.for %arg4 = 0 to 56 {
            affine.for %arg5 = 0 to 56 {
              affine.store %cst_1, %21[] : memref<f32>
              affine.for %arg6 = 0 to 64 {
                affine.for %arg7 = max #map9(%arg4) to min #map10(%arg4) {
                  affine.for %arg8 = max #map11(%arg4, %arg5) to min #map12(%arg4, %arg5) {
                    %117 = affine.apply #map13(%arg6, %arg2)
                    %118 = affine.apply #map14(%arg7, %arg4)
                    %119 = affine.apply #map14(%arg8, %arg5)
                    %120 = affine.load %17[%arg1, %117, %118, %119] : memref<1x64x56x56xf32>
                    %121 = affine.load %18[%113, %arg6, %arg7, %arg8] : memref<64x64x3x3xf32>
                    %122 = affine.load %21[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %21[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %21[] : memref<f32>
              %115 = affine.load %19[%113] : memref<64xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %20[%arg1, %113, %arg4, %arg5] : memref<1x64x56x56xf32>
            }
          }
        }
      }
    }
    %22 = memref.alloc() {alignment = 16 : i64} : memref<1x64x56x56xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 64 {
        affine.for %arg3 = 0 to 56 {
          affine.for %arg4 = 0 to 56 {
            %113 = affine.load %20[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %22[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
          }
        }
      }
    }
    %23 = "krnl.global"() {name = "constant_8", shape = [64, 64, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<64x64x3x3xf32>} : () -> memref<64x64x3x3xf32>
    %24 = "krnl.global"() {name = "constant_9", shape = [64], value = dense<[-0.113266408, 0.231644347, -1.17057312, 0.0128004849, -0.118708327, -0.0424110144, -0.304010749, -0.236697674, 0.724875569, 0.377743155, -0.245002747, 0.0085446611, -0.130037963, 1.07994354, -0.252043962, 0.0856727138, 0.107511804, 0.24361977, -0.230859295, -0.00711072981, -1.907660e-02, -0.145813763, -0.0542538203, -0.0561820082, -0.234453902, 0.110141575, 0.0821225419, 0.186844751, 1.08439314, 0.0504877158, 0.0967329591, 0.201199114, 0.828603088, -0.0433596969, 0.719374179, -0.163956791, 0.980644345, 0.362046152, 0.62723428, 0.189638913, -0.0204153955, -0.284641713, -0.160319418, 0.424594343, 0.521721959, 0.192806095, 0.54213506, -0.0253926963, 0.292299867, 0.520400465, 0.102515385, -0.191660613, 0.259327918, -0.0751645714, 0.0397105515, -0.457419157, -0.268625677, 0.214379802, 0.125779703, -0.299191117, -0.146437615, 0.048273474, 0.037529055, -0.285870194]> : tensor<64xf32>} : () -> memref<64xf32>
    %25 = memref.alloc() {alignment = 16 : i64} : memref<1x64x56x56xf32>
    %26 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 64 {
          %113 = affine.apply #map0(%arg2, %arg3)
          affine.for %arg4 = 0 to 56 {
            affine.for %arg5 = 0 to 56 {
              affine.store %cst_1, %26[] : memref<f32>
              affine.for %arg6 = 0 to 64 {
                affine.for %arg7 = max #map9(%arg4) to min #map10(%arg4) {
                  affine.for %arg8 = max #map11(%arg4, %arg5) to min #map12(%arg4, %arg5) {
                    %117 = affine.apply #map13(%arg6, %arg2)
                    %118 = affine.apply #map14(%arg7, %arg4)
                    %119 = affine.apply #map14(%arg8, %arg5)
                    %120 = affine.load %22[%arg1, %117, %118, %119] : memref<1x64x56x56xf32>
                    %121 = affine.load %23[%113, %arg6, %arg7, %arg8] : memref<64x64x3x3xf32>
                    %122 = affine.load %26[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %26[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %26[] : memref<f32>
              %115 = affine.load %24[%113] : memref<64xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %25[%arg1, %113, %arg4, %arg5] : memref<1x64x56x56xf32>
            }
          }
        }
      }
    }
    %27 = memref.alloc() {alignment = 16 : i64} : memref<1x64x56x56xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 64 {
        affine.for %arg3 = 0 to 56 {
          affine.for %arg4 = 0 to 56 {
            %113 = affine.load %25[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
            %114 = affine.load %17[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
            %115 = arith.addf %113, %114 : f32
            affine.store %115, %27[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
          }
        }
      }
    }
    %28 = memref.alloc() {alignment = 16 : i64} : memref<1x64x56x56xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 64 {
        affine.for %arg3 = 0 to 56 {
          affine.for %arg4 = 0 to 56 {
            %113 = affine.load %27[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %28[%arg1, %arg2, %arg3, %arg4] : memref<1x64x56x56xf32>
          }
        }
      }
    }
    %29 = "krnl.global"() {name = "constant_10", shape = [128, 64, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<128x64x3x3xf32>} : () -> memref<128x64x3x3xf32>
    %30 = "krnl.global"() {name = "constant_11", shape = [128], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<128xf32>} : () -> memref<128xf32>
    %31 = memref.alloc() {alignment = 16 : i64} : memref<1x128x28x28xf32>
    %32 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 128 {
          %113 = affine.apply #map15(%arg2, %arg3)
          affine.for %arg4 = 0 to 28 {
            affine.for %arg5 = 0 to 28 {
              affine.store %cst_1, %32[] : memref<f32>
              affine.for %arg6 = 0 to 64 {
                affine.for %arg7 = max #map16(%arg4) to min #map17(%arg4) {
                  affine.for %arg8 = max #map18(%arg4, %arg5) to min #map19(%arg4, %arg5) {
                    %117 = affine.apply #map13(%arg6, %arg2)
                    %118 = affine.apply #map20(%arg7, %arg4)
                    %119 = affine.apply #map20(%arg8, %arg5)
                    %120 = affine.load %28[%arg1, %117, %118, %119] : memref<1x64x56x56xf32>
                    %121 = affine.load %29[%113, %arg6, %arg7, %arg8] : memref<128x64x3x3xf32>
                    %122 = affine.load %32[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %32[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %32[] : memref<f32>
              %115 = affine.load %30[%113] : memref<128xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %31[%arg1, %113, %arg4, %arg5] : memref<1x128x28x28xf32>
            }
          }
        }
      }
    }
    %33 = memref.alloc() {alignment = 16 : i64} : memref<1x128x28x28xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 128 {
        affine.for %arg3 = 0 to 28 {
          affine.for %arg4 = 0 to 28 {
            %113 = affine.load %31[%arg1, %arg2, %arg3, %arg4] : memref<1x128x28x28xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %33[%arg1, %arg2, %arg3, %arg4] : memref<1x128x28x28xf32>
          }
        }
      }
    }
    %34 = "krnl.global"() {name = "constant_12", shape = [128, 128, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<128x128x3x3xf32>} : () -> memref<128x128x3x3xf32>
    %35 = "krnl.global"() {name = "constant_13", shape = [128], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<128xf32>} : () -> memref<128xf32>
    %36 = memref.alloc() {alignment = 16 : i64} : memref<1x128x28x28xf32>
    %37 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 128 {
          %113 = affine.apply #map15(%arg2, %arg3)
          affine.for %arg4 = 0 to 28 {
            affine.for %arg5 = 0 to 28 {
              affine.store %cst_1, %37[] : memref<f32>
              affine.for %arg6 = 0 to 128 {
                affine.for %arg7 = max #map9(%arg4) to min #map21(%arg4) {
                  affine.for %arg8 = max #map11(%arg4, %arg5) to min #map22(%arg4, %arg5) {
                    %117 = affine.apply #map23(%arg6, %arg2)
                    %118 = affine.apply #map14(%arg7, %arg4)
                    %119 = affine.apply #map14(%arg8, %arg5)
                    %120 = affine.load %33[%arg1, %117, %118, %119] : memref<1x128x28x28xf32>
                    %121 = affine.load %34[%113, %arg6, %arg7, %arg8] : memref<128x128x3x3xf32>
                    %122 = affine.load %37[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %37[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %37[] : memref<f32>
              %115 = affine.load %35[%113] : memref<128xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %36[%arg1, %113, %arg4, %arg5] : memref<1x128x28x28xf32>
            }
          }
        }
      }
    }
    %38 = "krnl.global"() {name = "constant_14", shape = [128, 64, 1, 1], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<128x64x1x1xf32>} : () -> memref<128x64x1x1xf32>
    %39 = "krnl.global"() {name = "constant_15", shape = [128], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<128xf32>} : () -> memref<128xf32>
    %40 = memref.alloc() {alignment = 16 : i64} : memref<1x128x28x28xf32>
    %41 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 128 {
          %113 = affine.apply #map15(%arg2, %arg3)
          affine.for %arg4 = 0 to 28 {
            affine.for %arg5 = 0 to 28 {
              affine.store %cst_1, %41[] : memref<f32>
              affine.for %arg6 = 0 to 64 {
                affine.for %arg7 = max #map24(%arg4) to min #map25(%arg4) {
                  affine.for %arg8 = max #map26(%arg4, %arg5) to min #map27(%arg4, %arg5) {
                    %117 = affine.apply #map13(%arg6, %arg2)
                    %118 = affine.apply #map28(%arg7, %arg4)
                    %119 = affine.apply #map28(%arg8, %arg5)
                    %120 = affine.load %28[%arg1, %117, %118, %119] : memref<1x64x56x56xf32>
                    %121 = affine.load %38[%113, %arg6, %arg7, %arg8] : memref<128x64x1x1xf32>
                    %122 = affine.load %41[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %41[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %41[] : memref<f32>
              %115 = affine.load %39[%113] : memref<128xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %40[%arg1, %113, %arg4, %arg5] : memref<1x128x28x28xf32>
            }
          }
        }
      }
    }
    %42 = memref.alloc() {alignment = 16 : i64} : memref<1x128x28x28xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 128 {
        affine.for %arg3 = 0 to 28 {
          affine.for %arg4 = 0 to 28 {
            %113 = affine.load %36[%arg1, %arg2, %arg3, %arg4] : memref<1x128x28x28xf32>
            %114 = affine.load %40[%arg1, %arg2, %arg3, %arg4] : memref<1x128x28x28xf32>
            %115 = arith.addf %113, %114 : f32
            affine.store %115, %42[%arg1, %arg2, %arg3, %arg4] : memref<1x128x28x28xf32>
          }
        }
      }
    }
    %43 = memref.alloc() {alignment = 16 : i64} : memref<1x128x28x28xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 128 {
        affine.for %arg3 = 0 to 28 {
          affine.for %arg4 = 0 to 28 {
            %113 = affine.load %42[%arg1, %arg2, %arg3, %arg4] : memref<1x128x28x28xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %43[%arg1, %arg2, %arg3, %arg4] : memref<1x128x28x28xf32>
          }
        }
      }
    }
    %44 = "krnl.global"() {name = "constant_16", shape = [128, 128, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<128x128x3x3xf32>} : () -> memref<128x128x3x3xf32>
    %45 = "krnl.global"() {name = "constant_17", shape = [128], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<128xf32>} : () -> memref<128xf32>
    %46 = memref.alloc() {alignment = 16 : i64} : memref<1x128x28x28xf32>
    %47 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 128 {
          %113 = affine.apply #map15(%arg2, %arg3)
          affine.for %arg4 = 0 to 28 {
            affine.for %arg5 = 0 to 28 {
              affine.store %cst_1, %47[] : memref<f32>
              affine.for %arg6 = 0 to 128 {
                affine.for %arg7 = max #map9(%arg4) to min #map21(%arg4) {
                  affine.for %arg8 = max #map11(%arg4, %arg5) to min #map22(%arg4, %arg5) {
                    %117 = affine.apply #map23(%arg6, %arg2)
                    %118 = affine.apply #map14(%arg7, %arg4)
                    %119 = affine.apply #map14(%arg8, %arg5)
                    %120 = affine.load %43[%arg1, %117, %118, %119] : memref<1x128x28x28xf32>
                    %121 = affine.load %44[%113, %arg6, %arg7, %arg8] : memref<128x128x3x3xf32>
                    %122 = affine.load %47[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %47[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %47[] : memref<f32>
              %115 = affine.load %45[%113] : memref<128xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %46[%arg1, %113, %arg4, %arg5] : memref<1x128x28x28xf32>
            }
          }
        }
      }
    }
    %48 = memref.alloc() {alignment = 16 : i64} : memref<1x128x28x28xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 128 {
        affine.for %arg3 = 0 to 28 {
          affine.for %arg4 = 0 to 28 {
            %113 = affine.load %46[%arg1, %arg2, %arg3, %arg4] : memref<1x128x28x28xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %48[%arg1, %arg2, %arg3, %arg4] : memref<1x128x28x28xf32>
          }
        }
      }
    }
    %49 = "krnl.global"() {name = "constant_18", shape = [128, 128, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<128x128x3x3xf32>} : () -> memref<128x128x3x3xf32>
    %50 = "krnl.global"() {name = "constant_19", shape = [128], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<128xf32>} : () -> memref<128xf32>
    %51 = memref.alloc() {alignment = 16 : i64} : memref<1x128x28x28xf32>
    %52 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 128 {
          %113 = affine.apply #map15(%arg2, %arg3)
          affine.for %arg4 = 0 to 28 {
            affine.for %arg5 = 0 to 28 {
              affine.store %cst_1, %52[] : memref<f32>
              affine.for %arg6 = 0 to 128 {
                affine.for %arg7 = max #map9(%arg4) to min #map21(%arg4) {
                  affine.for %arg8 = max #map11(%arg4, %arg5) to min #map22(%arg4, %arg5) {
                    %117 = affine.apply #map23(%arg6, %arg2)
                    %118 = affine.apply #map14(%arg7, %arg4)
                    %119 = affine.apply #map14(%arg8, %arg5)
                    %120 = affine.load %48[%arg1, %117, %118, %119] : memref<1x128x28x28xf32>
                    %121 = affine.load %49[%113, %arg6, %arg7, %arg8] : memref<128x128x3x3xf32>
                    %122 = affine.load %52[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %52[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %52[] : memref<f32>
              %115 = affine.load %50[%113] : memref<128xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %51[%arg1, %113, %arg4, %arg5] : memref<1x128x28x28xf32>
            }
          }
        }
      }
    }
    %53 = memref.alloc() {alignment = 16 : i64} : memref<1x128x28x28xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 128 {
        affine.for %arg3 = 0 to 28 {
          affine.for %arg4 = 0 to 28 {
            %113 = affine.load %51[%arg1, %arg2, %arg3, %arg4] : memref<1x128x28x28xf32>
            %114 = affine.load %43[%arg1, %arg2, %arg3, %arg4] : memref<1x128x28x28xf32>
            %115 = arith.addf %113, %114 : f32
            affine.store %115, %53[%arg1, %arg2, %arg3, %arg4] : memref<1x128x28x28xf32>
          }
        }
      }
    }
    %54 = memref.alloc() {alignment = 16 : i64} : memref<1x128x28x28xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 128 {
        affine.for %arg3 = 0 to 28 {
          affine.for %arg4 = 0 to 28 {
            %113 = affine.load %53[%arg1, %arg2, %arg3, %arg4] : memref<1x128x28x28xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %54[%arg1, %arg2, %arg3, %arg4] : memref<1x128x28x28xf32>
          }
        }
      }
    }
    %55 = "krnl.global"() {name = "constant_20", shape = [256, 128, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<256x128x3x3xf32>} : () -> memref<256x128x3x3xf32>
    %56 = "krnl.global"() {name = "constant_21", shape = [256], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<256xf32>} : () -> memref<256xf32>
    %57 = memref.alloc() {alignment = 16 : i64} : memref<1x256x14x14xf32>
    %58 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 256 {
          %113 = affine.apply #map29(%arg2, %arg3)
          affine.for %arg4 = 0 to 14 {
            affine.for %arg5 = 0 to 14 {
              affine.store %cst_1, %58[] : memref<f32>
              affine.for %arg6 = 0 to 128 {
                affine.for %arg7 = max #map16(%arg4) to min #map30(%arg4) {
                  affine.for %arg8 = max #map18(%arg4, %arg5) to min #map31(%arg4, %arg5) {
                    %117 = affine.apply #map23(%arg6, %arg2)
                    %118 = affine.apply #map20(%arg7, %arg4)
                    %119 = affine.apply #map20(%arg8, %arg5)
                    %120 = affine.load %54[%arg1, %117, %118, %119] : memref<1x128x28x28xf32>
                    %121 = affine.load %55[%113, %arg6, %arg7, %arg8] : memref<256x128x3x3xf32>
                    %122 = affine.load %58[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %58[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %58[] : memref<f32>
              %115 = affine.load %56[%113] : memref<256xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %57[%arg1, %113, %arg4, %arg5] : memref<1x256x14x14xf32>
            }
          }
        }
      }
    }
    %59 = memref.alloc() {alignment = 16 : i64} : memref<1x256x14x14xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 256 {
        affine.for %arg3 = 0 to 14 {
          affine.for %arg4 = 0 to 14 {
            %113 = affine.load %57[%arg1, %arg2, %arg3, %arg4] : memref<1x256x14x14xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %59[%arg1, %arg2, %arg3, %arg4] : memref<1x256x14x14xf32>
          }
        }
      }
    }
    %60 = "krnl.global"() {name = "constant_22", shape = [256, 256, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<256x256x3x3xf32>} : () -> memref<256x256x3x3xf32>
    %61 = "krnl.global"() {name = "constant_23", shape = [256], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<256xf32>} : () -> memref<256xf32>
    %62 = memref.alloc() {alignment = 16 : i64} : memref<1x256x14x14xf32>
    %63 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 256 {
          %113 = affine.apply #map29(%arg2, %arg3)
          affine.for %arg4 = 0 to 14 {
            affine.for %arg5 = 0 to 14 {
              affine.store %cst_1, %63[] : memref<f32>
              affine.for %arg6 = 0 to 256 {
                affine.for %arg7 = max #map9(%arg4) to min #map32(%arg4) {
                  affine.for %arg8 = max #map11(%arg4, %arg5) to min #map33(%arg4, %arg5) {
                    %117 = affine.apply #map34(%arg6, %arg2)
                    %118 = affine.apply #map14(%arg7, %arg4)
                    %119 = affine.apply #map14(%arg8, %arg5)
                    %120 = affine.load %59[%arg1, %117, %118, %119] : memref<1x256x14x14xf32>
                    %121 = affine.load %60[%113, %arg6, %arg7, %arg8] : memref<256x256x3x3xf32>
                    %122 = affine.load %63[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %63[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %63[] : memref<f32>
              %115 = affine.load %61[%113] : memref<256xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %62[%arg1, %113, %arg4, %arg5] : memref<1x256x14x14xf32>
            }
          }
        }
      }
    }
    %64 = "krnl.global"() {name = "constant_24", shape = [256, 128, 1, 1], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<256x128x1x1xf32>} : () -> memref<256x128x1x1xf32>
    %65 = "krnl.global"() {name = "constant_25", shape = [256], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<256xf32>} : () -> memref<256xf32>
    %66 = memref.alloc() {alignment = 16 : i64} : memref<1x256x14x14xf32>
    %67 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 256 {
          %113 = affine.apply #map29(%arg2, %arg3)
          affine.for %arg4 = 0 to 14 {
            affine.for %arg5 = 0 to 14 {
              affine.store %cst_1, %67[] : memref<f32>
              affine.for %arg6 = 0 to 128 {
                affine.for %arg7 = max #map24(%arg4) to min #map35(%arg4) {
                  affine.for %arg8 = max #map26(%arg4, %arg5) to min #map36(%arg4, %arg5) {
                    %117 = affine.apply #map23(%arg6, %arg2)
                    %118 = affine.apply #map28(%arg7, %arg4)
                    %119 = affine.apply #map28(%arg8, %arg5)
                    %120 = affine.load %54[%arg1, %117, %118, %119] : memref<1x128x28x28xf32>
                    %121 = affine.load %64[%113, %arg6, %arg7, %arg8] : memref<256x128x1x1xf32>
                    %122 = affine.load %67[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %67[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %67[] : memref<f32>
              %115 = affine.load %65[%113] : memref<256xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %66[%arg1, %113, %arg4, %arg5] : memref<1x256x14x14xf32>
            }
          }
        }
      }
    }
    %68 = memref.alloc() {alignment = 16 : i64} : memref<1x256x14x14xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 256 {
        affine.for %arg3 = 0 to 14 {
          affine.for %arg4 = 0 to 14 {
            %113 = affine.load %62[%arg1, %arg2, %arg3, %arg4] : memref<1x256x14x14xf32>
            %114 = affine.load %66[%arg1, %arg2, %arg3, %arg4] : memref<1x256x14x14xf32>
            %115 = arith.addf %113, %114 : f32
            affine.store %115, %68[%arg1, %arg2, %arg3, %arg4] : memref<1x256x14x14xf32>
          }
        }
      }
    }
    %69 = memref.alloc() {alignment = 16 : i64} : memref<1x256x14x14xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 256 {
        affine.for %arg3 = 0 to 14 {
          affine.for %arg4 = 0 to 14 {
            %113 = affine.load %68[%arg1, %arg2, %arg3, %arg4] : memref<1x256x14x14xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %69[%arg1, %arg2, %arg3, %arg4] : memref<1x256x14x14xf32>
          }
        }
      }
    }
    %70 = "krnl.global"() {name = "constant_26", shape = [256, 256, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<256x256x3x3xf32>} : () -> memref<256x256x3x3xf32>
    %71 = "krnl.global"() {name = "constant_27", shape = [256], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<256xf32>} : () -> memref<256xf32>
    %72 = memref.alloc() {alignment = 16 : i64} : memref<1x256x14x14xf32>
    %73 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 256 {
          %113 = affine.apply #map29(%arg2, %arg3)
          affine.for %arg4 = 0 to 14 {
            affine.for %arg5 = 0 to 14 {
              affine.store %cst_1, %73[] : memref<f32>
              affine.for %arg6 = 0 to 256 {
                affine.for %arg7 = max #map9(%arg4) to min #map32(%arg4) {
                  affine.for %arg8 = max #map11(%arg4, %arg5) to min #map33(%arg4, %arg5) {
                    %117 = affine.apply #map34(%arg6, %arg2)
                    %118 = affine.apply #map14(%arg7, %arg4)
                    %119 = affine.apply #map14(%arg8, %arg5)
                    %120 = affine.load %69[%arg1, %117, %118, %119] : memref<1x256x14x14xf32>
                    %121 = affine.load %70[%113, %arg6, %arg7, %arg8] : memref<256x256x3x3xf32>
                    %122 = affine.load %73[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %73[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %73[] : memref<f32>
              %115 = affine.load %71[%113] : memref<256xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %72[%arg1, %113, %arg4, %arg5] : memref<1x256x14x14xf32>
            }
          }
        }
      }
    }
    %74 = memref.alloc() {alignment = 16 : i64} : memref<1x256x14x14xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 256 {
        affine.for %arg3 = 0 to 14 {
          affine.for %arg4 = 0 to 14 {
            %113 = affine.load %72[%arg1, %arg2, %arg3, %arg4] : memref<1x256x14x14xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %74[%arg1, %arg2, %arg3, %arg4] : memref<1x256x14x14xf32>
          }
        }
      }
    }
    %75 = "krnl.global"() {name = "constant_28", shape = [256, 256, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<256x256x3x3xf32>} : () -> memref<256x256x3x3xf32>
    %76 = "krnl.global"() {name = "constant_29", shape = [256], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<256xf32>} : () -> memref<256xf32>
    %77 = memref.alloc() {alignment = 16 : i64} : memref<1x256x14x14xf32>
    %78 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 256 {
          %113 = affine.apply #map29(%arg2, %arg3)
          affine.for %arg4 = 0 to 14 {
            affine.for %arg5 = 0 to 14 {
              affine.store %cst_1, %78[] : memref<f32>
              affine.for %arg6 = 0 to 256 {
                affine.for %arg7 = max #map9(%arg4) to min #map32(%arg4) {
                  affine.for %arg8 = max #map11(%arg4, %arg5) to min #map33(%arg4, %arg5) {
                    %117 = affine.apply #map34(%arg6, %arg2)
                    %118 = affine.apply #map14(%arg7, %arg4)
                    %119 = affine.apply #map14(%arg8, %arg5)
                    %120 = affine.load %74[%arg1, %117, %118, %119] : memref<1x256x14x14xf32>
                    %121 = affine.load %75[%113, %arg6, %arg7, %arg8] : memref<256x256x3x3xf32>
                    %122 = affine.load %78[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %78[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %78[] : memref<f32>
              %115 = affine.load %76[%113] : memref<256xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %77[%arg1, %113, %arg4, %arg5] : memref<1x256x14x14xf32>
            }
          }
        }
      }
    }
    %79 = memref.alloc() {alignment = 16 : i64} : memref<1x256x14x14xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 256 {
        affine.for %arg3 = 0 to 14 {
          affine.for %arg4 = 0 to 14 {
            %113 = affine.load %77[%arg1, %arg2, %arg3, %arg4] : memref<1x256x14x14xf32>
            %114 = affine.load %69[%arg1, %arg2, %arg3, %arg4] : memref<1x256x14x14xf32>
            %115 = arith.addf %113, %114 : f32
            affine.store %115, %79[%arg1, %arg2, %arg3, %arg4] : memref<1x256x14x14xf32>
          }
        }
      }
    }
    %80 = memref.alloc() {alignment = 16 : i64} : memref<1x256x14x14xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 256 {
        affine.for %arg3 = 0 to 14 {
          affine.for %arg4 = 0 to 14 {
            %113 = affine.load %79[%arg1, %arg2, %arg3, %arg4] : memref<1x256x14x14xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %80[%arg1, %arg2, %arg3, %arg4] : memref<1x256x14x14xf32>
          }
        }
      }
    }
    %81 = "krnl.global"() {name = "constant_30", shape = [512, 256, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<512x256x3x3xf32>} : () -> memref<512x256x3x3xf32>
    %82 = "krnl.global"() {name = "constant_31", shape = [512], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<512xf32>} : () -> memref<512xf32>
    %83 = memref.alloc() {alignment = 16 : i64} : memref<1x512x7x7xf32>
    %84 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 512 {
          %113 = affine.apply #map37(%arg2, %arg3)
          affine.for %arg4 = 0 to 7 {
            affine.for %arg5 = 0 to 7 {
              affine.store %cst_1, %84[] : memref<f32>
              affine.for %arg6 = 0 to 256 {
                affine.for %arg7 = max #map16(%arg4) to min #map38(%arg4) {
                  affine.for %arg8 = max #map18(%arg4, %arg5) to min #map39(%arg4, %arg5) {
                    %117 = affine.apply #map34(%arg6, %arg2)
                    %118 = affine.apply #map20(%arg7, %arg4)
                    %119 = affine.apply #map20(%arg8, %arg5)
                    %120 = affine.load %80[%arg1, %117, %118, %119] : memref<1x256x14x14xf32>
                    %121 = affine.load %81[%113, %arg6, %arg7, %arg8] : memref<512x256x3x3xf32>
                    %122 = affine.load %84[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %84[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %84[] : memref<f32>
              %115 = affine.load %82[%113] : memref<512xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %83[%arg1, %113, %arg4, %arg5] : memref<1x512x7x7xf32>
            }
          }
        }
      }
    }
    %85 = memref.alloc() {alignment = 16 : i64} : memref<1x512x7x7xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 512 {
        affine.for %arg3 = 0 to 7 {
          affine.for %arg4 = 0 to 7 {
            %113 = affine.load %83[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %85[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
          }
        }
      }
    }
    %86 = "krnl.global"() {name = "constant_32", shape = [512, 512, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<512x512x3x3xf32>} : () -> memref<512x512x3x3xf32>
    %87 = "krnl.global"() {name = "constant_33", shape = [512], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<512xf32>} : () -> memref<512xf32>
    %88 = memref.alloc() {alignment = 16 : i64} : memref<1x512x7x7xf32>
    %89 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 512 {
          %113 = affine.apply #map37(%arg2, %arg3)
          affine.for %arg4 = 0 to 7 {
            affine.for %arg5 = 0 to 7 {
              affine.store %cst_1, %89[] : memref<f32>
              affine.for %arg6 = 0 to 512 {
                affine.for %arg7 = max #map9(%arg4) to min #map40(%arg4) {
                  affine.for %arg8 = max #map11(%arg4, %arg5) to min #map41(%arg4, %arg5) {
                    %117 = affine.apply #map42(%arg6, %arg2)
                    %118 = affine.apply #map14(%arg7, %arg4)
                    %119 = affine.apply #map14(%arg8, %arg5)
                    %120 = affine.load %85[%arg1, %117, %118, %119] : memref<1x512x7x7xf32>
                    %121 = affine.load %86[%113, %arg6, %arg7, %arg8] : memref<512x512x3x3xf32>
                    %122 = affine.load %89[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %89[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %89[] : memref<f32>
              %115 = affine.load %87[%113] : memref<512xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %88[%arg1, %113, %arg4, %arg5] : memref<1x512x7x7xf32>
            }
          }
        }
      }
    }
    %90 = "krnl.global"() {name = "constant_34", shape = [512, 256, 1, 1], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<512x256x1x1xf32>} : () -> memref<512x256x1x1xf32>
    %91 = "krnl.global"() {name = "constant_35", shape = [512], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<512xf32>} : () -> memref<512xf32>
    %92 = memref.alloc() {alignment = 16 : i64} : memref<1x512x7x7xf32>
    %93 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 512 {
          %113 = affine.apply #map37(%arg2, %arg3)
          affine.for %arg4 = 0 to 7 {
            affine.for %arg5 = 0 to 7 {
              affine.store %cst_1, %93[] : memref<f32>
              affine.for %arg6 = 0 to 256 {
                affine.for %arg7 = max #map24(%arg4) to min #map43(%arg4) {
                  affine.for %arg8 = max #map26(%arg4, %arg5) to min #map44(%arg4, %arg5) {
                    %117 = affine.apply #map34(%arg6, %arg2)
                    %118 = affine.apply #map28(%arg7, %arg4)
                    %119 = affine.apply #map28(%arg8, %arg5)
                    %120 = affine.load %80[%arg1, %117, %118, %119] : memref<1x256x14x14xf32>
                    %121 = affine.load %90[%113, %arg6, %arg7, %arg8] : memref<512x256x1x1xf32>
                    %122 = affine.load %93[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %93[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %93[] : memref<f32>
              %115 = affine.load %91[%113] : memref<512xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %92[%arg1, %113, %arg4, %arg5] : memref<1x512x7x7xf32>
            }
          }
        }
      }
    }
    %94 = memref.alloc() {alignment = 16 : i64} : memref<1x512x7x7xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 512 {
        affine.for %arg3 = 0 to 7 {
          affine.for %arg4 = 0 to 7 {
            %113 = affine.load %88[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
            %114 = affine.load %92[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
            %115 = arith.addf %113, %114 : f32
            affine.store %115, %94[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
          }
        }
      }
    }
    %95 = memref.alloc() {alignment = 16 : i64} : memref<1x512x7x7xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 512 {
        affine.for %arg3 = 0 to 7 {
          affine.for %arg4 = 0 to 7 {
            %113 = affine.load %94[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %95[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
          }
        }
      }
    }
    %96 = "krnl.global"() {name = "constant_36", shape = [512, 512, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<512x512x3x3xf32>} : () -> memref<512x512x3x3xf32>
    %97 = "krnl.global"() {name = "constant_37", shape = [512], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<512xf32>} : () -> memref<512xf32>
    %98 = memref.alloc() {alignment = 16 : i64} : memref<1x512x7x7xf32>
    %99 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 512 {
          %113 = affine.apply #map37(%arg2, %arg3)
          affine.for %arg4 = 0 to 7 {
            affine.for %arg5 = 0 to 7 {
              affine.store %cst_1, %99[] : memref<f32>
              affine.for %arg6 = 0 to 512 {
                affine.for %arg7 = max #map9(%arg4) to min #map40(%arg4) {
                  affine.for %arg8 = max #map11(%arg4, %arg5) to min #map41(%arg4, %arg5) {
                    %117 = affine.apply #map42(%arg6, %arg2)
                    %118 = affine.apply #map14(%arg7, %arg4)
                    %119 = affine.apply #map14(%arg8, %arg5)
                    %120 = affine.load %95[%arg1, %117, %118, %119] : memref<1x512x7x7xf32>
                    %121 = affine.load %96[%113, %arg6, %arg7, %arg8] : memref<512x512x3x3xf32>
                    %122 = affine.load %99[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %99[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %99[] : memref<f32>
              %115 = affine.load %97[%113] : memref<512xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %98[%arg1, %113, %arg4, %arg5] : memref<1x512x7x7xf32>
            }
          }
        }
      }
    }
    %100 = memref.alloc() {alignment = 16 : i64} : memref<1x512x7x7xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 512 {
        affine.for %arg3 = 0 to 7 {
          affine.for %arg4 = 0 to 7 {
            %113 = affine.load %98[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %100[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
          }
        }
      }
    }
    %101 = "krnl.global"() {name = "constant_38", shape = [512, 512, 3, 3], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<512x512x3x3xf32>} : () -> memref<512x512x3x3xf32>
    %102 = "krnl.global"() {name = "constant_39", shape = [512], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<512xf32>} : () -> memref<512xf32>
    %103 = memref.alloc() {alignment = 16 : i64} : memref<1x512x7x7xf32>
    %104 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1 {
        affine.for %arg3 = 0 to 512 {
          %113 = affine.apply #map37(%arg2, %arg3)
          affine.for %arg4 = 0 to 7 {
            affine.for %arg5 = 0 to 7 {
              affine.store %cst_1, %104[] : memref<f32>
              affine.for %arg6 = 0 to 512 {
                affine.for %arg7 = max #map9(%arg4) to min #map40(%arg4) {
                  affine.for %arg8 = max #map11(%arg4, %arg5) to min #map41(%arg4, %arg5) {
                    %117 = affine.apply #map42(%arg6, %arg2)
                    %118 = affine.apply #map14(%arg7, %arg4)
                    %119 = affine.apply #map14(%arg8, %arg5)
                    %120 = affine.load %100[%arg1, %117, %118, %119] : memref<1x512x7x7xf32>
                    %121 = affine.load %101[%113, %arg6, %arg7, %arg8] : memref<512x512x3x3xf32>
                    %122 = affine.load %104[] : memref<f32>
                    %123 = arith.mulf %120, %121 : f32
                    %124 = arith.addf %122, %123 : f32
                    affine.store %124, %104[] : memref<f32>
                  }
                }
              }
              %114 = affine.load %104[] : memref<f32>
              %115 = affine.load %102[%113] : memref<512xf32>
              %116 = arith.addf %114, %115 : f32
              affine.store %116, %103[%arg1, %113, %arg4, %arg5] : memref<1x512x7x7xf32>
            }
          }
        }
      }
    }
    %105 = memref.alloc() {alignment = 16 : i64} : memref<1x512x7x7xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 512 {
        affine.for %arg3 = 0 to 7 {
          affine.for %arg4 = 0 to 7 {
            %113 = affine.load %103[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
            %114 = affine.load %95[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
            %115 = arith.addf %113, %114 : f32
            affine.store %115, %105[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
          }
        }
      }
    }
    %106 = memref.alloc() {alignment = 16 : i64} : memref<1x512x7x7xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 512 {
        affine.for %arg3 = 0 to 7 {
          affine.for %arg4 = 0 to 7 {
            %113 = affine.load %105[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
            %114 = arith.cmpf olt, %113, %cst_1 : f32
            %115 = arith.select %114, %cst_1, %113 : f32
            affine.store %115, %106[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
          }
        }
      }
    }
    %107 = memref.alloc() {alignment = 16 : i64} : memref<1x512x1x1xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 512 {
        affine.for %arg3 = 0 to 1 {
          affine.for %arg4 = 0 to 1 {
            affine.store %cst_1, %107[%arg1, %arg2, %arg3, %arg4] : memref<1x512x1x1xf32>
          }
        }
      }
    }
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 512 {
        affine.for %arg3 = 0 to 7 {
          affine.for %arg4 = 0 to 7 {
            %113 = affine.load %106[%arg1, %arg2, %arg3, %arg4] : memref<1x512x7x7xf32>
            %114 = affine.load %107[%arg1, %arg2, %c0, %c0] : memref<1x512x1x1xf32>
            %115 = arith.addf %114, %113 : f32
            affine.store %115, %107[%arg1, %arg2, %c0, %c0] : memref<1x512x1x1xf32>
          }
        }
      }
    }
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 512 {
        affine.for %arg3 = 0 to 1 {
          affine.for %arg4 = 0 to 1 {
            %113 = affine.load %107[%arg1, %arg2, %arg3, %arg4] : memref<1x512x1x1xf32>
            %114 = arith.divf %113, %cst_0 : f32
            affine.store %114, %107[%arg1, %arg2, %arg3, %arg4] : memref<1x512x1x1xf32>
          }
        }
      }
    }
    %108 = memref.alloc() {alignment = 16 : i64} : memref<1x512xf32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 512 {
        affine.for %arg3 = 0 to 1 {
          affine.for %arg4 = 0 to 1 {
            %113 = affine.load %107[%arg1, %arg2, %arg3, %arg4] : memref<1x512x1x1xf32>
            %114 = affine.apply #map45(%arg2, %arg3, %arg4)
            affine.store %113, %108[%arg1, %114] : memref<1x512xf32>
          }
        }
      }
    }
    %109 = "krnl.global"() {name = "constant_40", shape = [1000, 512], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<1000x512xf32>} : () -> memref<1000x512xf32>
    %110 = "krnl.global"() {name = "constant_41", shape = [1000], value = opaque<"elided_large_const", "0xDEADBEEF"> : tensor<1000xf32>} : () -> memref<1000xf32>
    %111 = memref.alloc() {alignment = 128 : i64} : memref<1x1000xf32>
    %112 = memref.alloca() : memref<f32>
    affine.for %arg1 = 0 to 1 {
      affine.for %arg2 = 0 to 1000 {
        affine.store %cst_1, %112[] : memref<f32>
        affine.for %arg3 = 0 to 512 {
          %116 = affine.load %108[%arg1, %arg3] : memref<1x512xf32>
          %117 = affine.load %109[%arg2, %arg3] : memref<1000x512xf32>
          %118 = arith.mulf %116, %117 : f32
          %119 = affine.load %112[] : memref<f32>
          %120 = arith.addf %118, %119 : f32
          affine.store %120, %112[] : memref<f32>
        }
        %113 = affine.load %112[] : memref<f32>
        %114 = affine.load %110[%arg2] : memref<1000xf32>
        %115 = arith.addf %113, %114 : f32
        affine.store %115, %111[%arg1, %arg2] : memref<1x1000xf32>
      }
    }
    return %111 : memref<1x1000xf32>
  }
  "krnl.entry_point"() {func = @main_graph, numInputs = 1 : i32, numOutputs = 1 : i32, signature = "[    { \22type\22 : \22f32\22 , \22dims\22 : [1 , 3 , 224 , 224] , \22name\22 : \22input\22 }\0A\0A]\00@[   { \22type\22 : \22f32\22 , \22dims\22 : [1 , 1000] , \22name\22 : \22191\22 }\0A\0A]\00"} : () -> ()
}
